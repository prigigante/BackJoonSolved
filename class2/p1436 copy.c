/**
 * 666이 연속되는 n번째로 작은 수 찾기
 * 설명에서는 브루트포스 알고리즘이라고 하는데
 * ==> 전부 다 해보기
 * 1666 2666 3666 4666 5666 6660 6666 7666 8666 9666 10666 11 12 13 14 15666 16660 16666 17666 18666 19666 20666
 * 99666 100666 105666 106660 106666 .... 150666 155666 156660 156666 157666 159666   160666   161666 165666 166600 // 165--- 166---
 * 1666-- 166601
 * 
 * 3자리수 4자리수 5자리수 6자리수 7자리수
 * 00000
 * --666
 * -6/66-
 * 66/6--
 * 
 * 
 * ------
 * ---/666
 * --6/66-
 * -66/6--
 * 666/---
 */




#include <stdio.h>

#define ADD_STANDARD 1000

int main(void){

    //맨 최상위 자릿수가 6으로 설정 되는 그 순간 /100하고 6번빼면 맨 뒤의 6이 사라짐

    // 66---이라는 숫자는 총 1000을 66번 더했을때 가능한 경우의 수
    // -6---이라는것은 총 1000을 6번 더했을때 나오는 경우
    //즉 6으로 쪼개지는 수가 존재함 => 66666....

    int target_count = 0, now_count = 0, now_number =0, is_div_by_six = 0;

    scanf("%d", &target_count);
    if(target_count == 1){
        printf("666");
        return 0;
    }
    now_count = 1, now_number = 666;

    now_count++;
    now_number = now_number + ADD_STANDARD;


    while(1){
        if(now_count == target_count){
            break;
        }
        now_count++;
        if(now_count % 6 == 0){
            //div by 6, no remain
            // => 
        }


    }


    return 0;
}